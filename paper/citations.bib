@book{CPROGRAMMINGLANGUAGE,
author = {Kernighan, Brian W. and Ritchie, Dennis M.},
title = {The C Programming Language},
year = {1988},
isbn = {0131103709},
publisher = {Prentice Hall Professional Technical Reference},
edition = {2nd},
abstract = {From the Publisher: This second editon describes C as defined by the ANSI standard. This book is meant to help the reader learn how to program in C. The book assumes some familiarity with basic programming concepts like variables, assignment statements, loops, and functions. A novice programmer should be able to read along and pick up the language. FEATURES: All examples have been tested, which is in machine-readable form. It discusses various aspects of C in more detail, although the emphasis is on examples of complete programs, rather than isolated fragments. It deals with basic data types, operators and expressions. Covers functions and program structure, external variables, scope rules, multiple source files, and also touches on the preprocessor. It also describes an interface between C programs and the UNIX operating system, concentrating on input/output, the file system, and storage allocation. It also provides a language reference manual. The official statement of the syntax and semantics of C is the ANSI standard.}
}

@book{TESTDRIVEN,
  asin = {0321146530},
  author = {Beck, Kent},
  biburl = {https://www.bibsonomy.org/bibtex/293ecb16d97b64f51a8cb72ab54dca15a/schmidt2},
  description = {Test Driven Development. By Example Addison-Wesley},
  dewey = {005.14},
  ean = {9780321146533},
  interhash = {ce3a9459ac3d0b3d47518f186cae5809},
  intrahash = {93ecb16d97b64f51a8cb72ab54dca15a},
  isbn = {0321146530},
  keywords = {addison-wesley books kent_beck},
  publisher = {Addison-Wesley Longman, Amsterdam},
  timestamp = {2011-07-19T11:31:41.000+0200},
  title = {Test Driven Development. By Example (Addison-Wesley Signature)},
  year = 2002
}

@inproceedings{VEEMODEL,
author = {Tierno, Antonio and Santos, Max and Arruda, Benedito and Rosa, Joao},
year = {2016},
month = {11},
pages = {1-8},
title = {Open issues for the automotive software testing},
doi = {10.1109/INDUSCON.2016.7874609}
}

@article{JAVAWHITEPAPER,
author = {Gosling, James},
year = {1995},
month = {02},
pages = {},
title = {"Java: an Overview" the original Java whitepaper}
}

@article{QUICKCHECK,
author = {Claessen, Koen and Hughes, John},
year = {2000},
month = {01},
pages = {},
title = {QuickCheck: A Lightweight Tool for Random Testing of Haskell Programs},
volume = {46},
journal = {Proceedings of the ACM SIGPLAN International Conference on Functional Programming, ICFP},
doi = {10.1145/1988042.1988046}
}

@article{CPPJAVA,
author = {Hundt, Robert},
year = {2011},
month = {01},
pages = {},
title = {Loop recognition in C++/Java/Go/Scala}
}

@inproceedings{IMPACTOFUNDEFINED,
author = {Wang, Xi and Zeldovich, Nickolai and Kaashoek, M. Frans and Solar-Lezama, Armando},
title = {Towards Optimization-Safe Systems: Analyzing the Impact of Undefined Behavior},
year = {2013},
isbn = {9781450323888},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2517349.2522728},
doi = {10.1145/2517349.2522728},
abstract = {This paper studies an emerging class of software bugs called optimization-unstable code: code that is unexpectedly discarded by compiler optimizations due to undefined behavior in the program. Unstable code is present in many systems, including the Linux kernel and the Postgres database. The consequences of unstable code range from incorrect functionality to missing security checks.To reason about unstable code, this paper proposes a novel model, which views unstable code in terms of optimizations that leverage undefined behavior. Using this model, we introduce a new static checker called Stack that precisely identifies unstable code. Applying Stack to widely used systems has uncovered 160 new bugs that have been confirmed and fixed by developers.},
booktitle = {Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles},
pages = {260–275},
numpages = {16},
location = {Farminton, Pennsylvania},
series = {SOSP '13}
}

@article{QUALITATIVE,
  doi = {10.1080/13814788.2017.1375092},
  url = {https://doi.org/10.1080/13814788.2017.1375092},
  year = {2017},
  month = dec,
  publisher = {Informa {UK} Limited},
  volume = {24},
  number = {1},
  pages = {120--124},
  author = {Irene Korstjens and Albine Moser},
  title = {Series: Practical guidance to qualitative research. Part 4: Trustworthiness and publishing},
  journal = {European Journal of General Practice}
}

@inproceedings{DEMYSTIFYING,
  doi = {10.1145/1508293.1508305},
  url = {https://doi.org/10.1145/1508293.1508305},
  year = {2009},
  publisher = {{ACM} Press},
  author = {Daniel Frampton and Stephen M. Blackburn and Perry Cheng and Robin J. Garner and David Grove and J. Eliot B. Moss and Sergey I. Salishev},
  title = {Demystifying magic},
  booktitle = {Proceedings of the 2009 {ACM} {SIGPLAN}/{SIGOPS} international conference on Virtual execution environments - {VEE} {\textquotesingle}09}
}

@book{PRACTICALTLA,
author = {Wayne, Hillel},
title = {Practical TLA+: Planning Driven Development},
year = {2018},
isbn = {1484238281},
publisher = {Apress},
address = {USA},
edition = {1st},
abstract = {Learn how to design complex, correct programs and fix problems before writing a single line of code. This book is a practical, comprehensive resource on TLA+ programming with rich, complex examples. Practical TLA+ shows you how to use TLA+ to specify a complex system and test the design itself for bugs. Youll learn how even a short TLA+ spec can find critical bugs. Start by getting your feet wet with an example of TLA+ used in a bank transfer system, to see how it helps you design, test, and build a better application. Then, get some fundamentals of TLA+ operators, logic, functions, PlusCal, models, and concurrency. Along the way you will discover how to organize your blueprints and how to specify distributed systems and eventual consistency. Finally, youll put what you learn into practice with some working case study applications, applying TLA+ to a wide variety of practical problems: from algorithm performance and data structures to business code and MapReduce. After reading and using this book, you'll have what you need to get started with TLA+ and how to use it in your mission-critical applications. What You'll Learn Read and write TLA+ specs Check specs for broken invariants, race conditions, and liveness bugs Design concurrency and distributed systems Learn how TLA+ can help you with your day-to-day production work Who This Book Is ForThose with programming experience who are new to design and to TLA+.}
}


@article{CPPHISTORY,
author = {Stroustrup, Bjarne},
year = {1993},
month = {03},
pages = {271-297},
title = {A history of C++: 1979–1991},
volume = {28},
journal = {Sigplan Notices - SIGPLAN},
doi = {10.1145/155360.155375}
}

@incollection{WHYAMAZONTLA,
  doi = {10.1007/978-3-662-43652-3_3},
  year = {2014},
  publisher = {Springer Berlin Heidelberg},
  pages = {25--39},
  author = {Chris Newcombe},
  title = {Why Amazon Chose {TLA}},
  booktitle = {Lecture Notes in Computer Science}
}


@manual{RUSTMANUAL,
  title ={{Rust Documentation std::option::Option}},
  howpublished = "ver. 1.0.0",
  year = {2021},
  url = {https://doc.rust-lang.org/std/option/enum.Option.html}
}


@manual{TLAMANUAL,
  author = {Leslie Lamport},
  title = "A PlusCal User’s Manual",
  howpublished = "ver. 1.8",
  year = {2020},
  url = {https://lamport.azurewebsites.net/tla/p-manual.pdf}
}

@software{LINKEDLISTREPO,
  author = {Fredriksson, Magnus and Öberg, Fredrik},
  title = {Exjobb repo},
  url = {[https://github.com/magfred-fobe/a-method-for-porting-software-using-formal-specifications]},
  version = {0.1.0},
  date = {2021-05-27},
}

@software{CBINDGEN,
  author = {eqrion},
  title = {cbindgen},
  url = {[https://github.com/eqrion/cbindgen]},
  version = {0.19.0},
  date = {2021-04-08},
}

@software{TLATOOLBOX,
  author = {Leslie Lamport},
  title = {TLA+ Toolbox},
  url = {https://lamport.azurewebsites.net/tla/toolbox.html},
  version = {1.7.1},
  date = {2021-01-04},
}

@software{MSVCC,
  author = {{Microsoft}},
  title = {VCC: A Verifier for Concurrent C},
  url = {https://www.microsoft.com/en-us/research/project/vcc-a-verifier-for-concurrent-c},
  version = {},
  date = {2021-01-20},
}

@software{ALLOY,
  author = {{Massachusets Institute of Technology}},
  title = {Alloy Analyzer},
  url = {https://alloytools.org},
  version = {5.1.0},
  date = {2019-08-14},
}

@misc{LAMPORTWEB,
    author = {Leslie Lamport},
	title = {The {TLA}+ {Home} {Page}},
	url = {https://lamport.azurewebsites.net/tla/tla.html},
	urldate = {2021-05-28},
	file = {The TLA+ Home Page:C\:\\Users\\Magnus\\Zotero\\storage\\P8CPT6A4\\tla.html:text/html}
}

@article{HOARE,
  doi = {10.1145/363235.363259},
  url = {https://doi.org/10.1145/363235.363259},
  year = {1969},
  month = oct,
  publisher = {Association for Computing Machinery ({ACM})},
  volume = {12},
  number = {10},
  pages = {576--580},
  author = {C. A. R. Hoare},
  title = {An axiomatic basis for computer programming},
  journal = {Communications of the {ACM}}
}

@misc{CMAKE,
	title = {cmake(1) — {CMake} 3.20.3 {Documentation}},
	url = {https://cmake.org/cmake/help/latest/manual/cmake.1.html},
	urldate = {2021-05-28},
	file = {cmake(1) — CMake 3.20.3 Documentation:C\:\\Users\\Magnus\\Zotero\\storage\\G9B5KMY6\\cmake.1.html:text/html}
}

@misc{CLION,
	title = {{CLion: A cross-platform IDE for C and C++}},
	url = {https://www.jetbrains.com/clion},
	urldate = {2021-06-10}
}


@manual{gcc_man,
 title      = "gcc(1) Linux User's Manual",
 %author        = "",
 %organization  = "",
 %address   = "",
 %edition   = "",
 year       = "2013",
 month      = "07",
 url = {[https://linux.die.net/man/1/gcc]}
 %note      = "",
}

@misc{GCC,
	title = {{GCC}, the {GNU} {Compiler} {Collection} - {GNU} {Project} - {Free} {Software} {Foundation} ({FSF})},
	url = {https://gcc.gnu.org/},
	urldate = {2021-05-28},
	file = {GCC, the GNU Compiler Collection - GNU Project - Free Software Foundation (FSF):C\:\\Users\\Magnus\\Zotero\\storage\\3FPCWWBH\\gcc.gnu.org.html:text/html}
}

@misc{RAPIDCHECK,
	title = {emil-e/rapidcheck},
	copyright = {BSD-2-Clause},
	url = {https://github.com/emil-e/rapidcheck},
	abstract = {QuickCheck clone for C++ with the goal of being simple to use with as little boilerplate as possible.},
	urldate = {2021-05-28},
	author = {emil-e},
	month = may,
	year = {2021},
	note = {original-date: 2014-05-08T20:19:43Z}
}

@misc{GOOGLETEST,
	title = {google/googletest},
	copyright = {BSD-3-Clause},
	url = {https://github.com/google/googletest},
	abstract = {GoogleTest - Google Testing and Mocking Framework},
	urldate = {2021-05-28},
	publisher = {Google},
	month = may,
	year = {2021},
	note = {original-date: 2015-07-28T15:07:53Z}
}

@misc{FREEBSD,
	title = {The {FreeBSD} {Project}},
	url = {https://www.freebsd.org/},
	urldate = {2021-05-28},
	file = {The FreeBSD Project:C\:\\Users\\Magnus\\Zotero\\storage\\EXXVDRFI\\www.freebsd.org.html:text/html}
}


@article{PROJECTCYCLE,
author = {Forsberg, Kevin and Mooz, H.},
year = {2015},
month = {04},
pages = {36-43},
title = {The Relationship of System Engineering to the Project Cycle},
volume = {4},
journal = {Engineering Management Journal},
doi = {10.1080/10429247.1992.11414684}
}


@book{THERUSTPROGRAMMINGLANGUAGE,
author = {Klabnik, Steve and Nichols, Carol},
title = {The Rust Programming Language},
year = {2018},
isbn = {1593278284},
publisher = {No Starch Press},
address = {USA},
abstract = {The Rust Programming Language is the official book on Rust, an open-source, community-developed systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety. This is the undisputed go-to guide to Rust, written by two members of the Rust core team, with feedback and contributions from 42 members of the community. The book assumes that youve written code in another programming language but makes no assumptions about which one, meaning the material is accessible and useful to developers from a wide variety of programming backgrounds. Known by the Rust community as The Book, The Rust Programming Language includes concept chapters, where youll learn about a particular aspect of Rust, and project chapters, where youll apply what youve learned so far to build small programs. The Book opens with a quick hands-on project to introduce the basics then explores key concepts in depth, such as ownership, the type system, error handling, and fearless concurrency. Next come detailed explanations of Rust-oriented perspectives on topics like pattern matching, iterators, and smart pointers, with concrete examples and exercises--taking you from theory to practice. The Rust Programming Language will also show you how to:- Grasp important concepts unique to Rust, like ownership, borrowing, and lifetimes- Use Cargo, Rusts built-in package manager, to build and maintain your code, including downloading and building dependencies- Effectively use Rusts zero-cost abstractions and employ your own Youll learn to develop reliable code thats speed and memory efficient, while avoiding the infamous and arcane programming pitfalls common at the systems level. When you need to dive down into lower-level control, this guide will show you how without taking on the customary risk of crashes or security holes and without requiring you to learn the fine points of a fickle toolchain. Youll also learn how to create command line programs, build single- and multithreaded web servers, and much more. The Rust Programming Language fully embraces Rusts potential to empower its users. This friendly and approachable guide will help you build not only your knowledge of Rust but also your ability to program with confidence in a wider variety of domains.}
}

@misc{RUSTONOMICON,
	title = {Introduction - {The} {Rustonomicon}},
	url = {https://doc.rust-lang.org/nomicon/},
	urldate = {2021-05-28}
}

@article{USINGFORMALSPECTESTING, title={Using formal specifications to support testing}, volume={41}, url={http://dx.doi.org/10.1145/1459352.1459354}, DOI={10.1145/1459352.1459354}, abstractNote={<jats:p>Formal methods and testing are two important approaches that assist in the development of high-quality software. While traditionally these approaches have been seen as rivals, in recent years a new consensus has developed in which they are seen as complementary. This article reviews the state of the art regarding ways in which the presence of a formal specification can be used to assist testing.</jats:p>}, number={2}, journal={ACM Computing Surveys}, publisher={Association for Computing Machinery (ACM)}, author={Hierons, Robert M. and Bogdanov, Kirill and Bowen, Jonathan P. and Cleaveland, Rance and Derrick, John and Dick, Jeremy and Gheorghe, Marian and Harman, Mark and Kapoor, Kalpesh and Krause, Paul and et al.}, year={2009}, month={02}, pages={1–76} }

@article{APPLYINGFORMALSPEC,
author = {Larsen, Peter and Fitzgerald, John and Brookes, Tom},
year = {1996},
month = {06},
pages = {48 - 56},
title = {Applying formal specification in industry},
volume = {13},
journal = {Software, IEEE},
doi = {10.1109/52.493020}
}

@book{sommerville_software_2011,
	address = {Boston},
	edition = {9th ed},
	title = {Software engineering},
	isbn = {9780135140758},
	publisher = {Pearson},
	author = {Sommerville, Ian},
	year = {2011},
	note = {OCLC: ocn462909026},
	keywords = {Software engineering}
}

@article{AMAZONFORMALSPEC,
author = {Newcombe, Chris and Rath, Tim and Zhang, Fan and Munteanu, Bogdan and Brooker, Marc and Deardeuff, Michael},
year = {2015},
month = {03},
pages = {66-73},
title = {How Amazon Web Services Uses Formal Methods},
volume = {58},
journal = {Communications of the ACM},
doi = {10.1145/2699417}
}

@misc{LAMPORTVIDEO,
	title = {{TLA}+ {Video} {Course}},
	url = {https://lamport.azurewebsites.net/video/videos.html},
	urldate = {2021-05-28},
	file = {TLA+ Video Course:C\:\\Users\\Magnus\\Zotero\\storage\\TZYXM2DZ\\videos.html:text/html}
}


@inproceedings{FORMALSPECROADMAP,
author = {Lamsweerde, Axel van},
title = {Formal Specification: A Roadmap},
year = {2000},
isbn = {1581132530},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/336512.336546},
doi = {10.1145/336512.336546},
booktitle = {Proceedings of the Conference on The Future of Software Engineering},
pages = {147–159},
numpages = {13},
location = {Limerick, Ireland},
series = {ICSE '00}
}

@book{Larch,
author = {Guttag, John V. and Horning, James J.},
title = {Larch: Languages and Tools for Formal Specification},
year = {1993},
isbn = {0387940065},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg}
}

@inproceedings{testingisnecessary,
author = {Nami, Mohammad and Suryn, Witold},
year = {2013},
month = {01},
pages = {34-44},
title = {Software Testing is Necessary But Not Sufficient for Software Trustworthiness},
volume = {320},
isbn = {978-3-642-35794-7},
journal = {Communications in Computer and Information Science},
doi = {10.1007/978-3-642-35795-4_5}
}


@article{comparison,  
author={Weiser, M.D. and Gannon, J.D. and McMullin, P.R.},  journal={IEEE Software},   title={Comparison of Structural Test Coverage Metrics},   
year={1985},  
volume={2},  
number={2},  
pages={80-85},  
doi={10.1109/MS.1985.230356}
}

@thesis{duregard_automating_2016,
	title = {Automating Black-Box Property Based Testing},
	url = {https://research.chalmers.se/en/publication/240807},
	abstract = {Black-box property based testing tools like {QuickCheck} allow developers to write elegant logical specifications of their programs, while still permitting unrestricted use of the same language features and libraries that simplify writing the programs themselves. This is an improvement over unit testing because a single property can replace a large collection of test cases, and over more heavy-weight white-box testing frameworks that impose restrictions on how properties and tested code are written. In most cases the developer only needs to write a function returning a boolean, something any developer is capable of without additional training. This thesis aims to further lower the threshold for using property based testing by automating some problematic areas, most notably generating test data for user defined data types. Writing procedures for random test data generation by hand is time consuming and error prone, and most fully automatic algorithms give very poor random distributions for practical cases. Several fully automatic algorithms for generating test data are presented in this thesis, along with implementations as Haskell libraries. These algorithms all fit nicely within a framework called sized functors, allowing re-usable generator definitions to be constructed automatically or by hand using a few simple combinators. Test quality is another difficulty with property based testing. When a property fails to find a counterexample there is always some uncertainty in the strength of the property as a specification. To address this problem we introduce a black-box variant of mutation testing. Usually mutation testing involves automatically introducing errors (mutations) in the source code of a tested program to see if a test suite can detect it. Using higher order functions, we mutate functions without accessing their source code. The result is a very light-weight mutation testing procedure that automatically estimates property strength for {QuickCheck} properties.},
	institution = {Chalmers University of Technology},
	type = {phdthesis},
	author = {Duregård, Jonas Almström},
	urldate = {2021-05-22},
	date = {2016},
	langid = {english},
	note = {{ISBN}: 9789175974316}
}