\section{Conclusion}\label{conclusion}

The result of the project indicates that the method described could be used as a basis when porting legacy code. The practice of creating a model based on tests, gave a solid foundation for building a port. Some cases were found where the method could be extended to consider properties of the source and target language. The target project may also affect the effectiveness of the method. The application of TLA+ as a modelling language was found to be a good choice and comes with the authors recommendations for software engineers trying to acquaint themselves with formal specifications. 

All in all, the experience working with the project has been rewarding and has given the authors many tools which will hopefully be useful in future endeavors. It will be interesting to see if formal specifications will enjoy a wider adoption in the future.

\subsection{Future Work}
It would be interesting to see the method applied to a more complex system. As has been mentioned in the discussion, a more complex system may make better use of a formal specification. If used by more experienced engineers it could also provide a greater insight in the efficiency of the method. 

The process described in this thesis explicitly did not consider the run-time characteristics of the system. This decision was taken to limit the scope of the process. However, it may be reasonable to extend the process taking these into account. As an example, in the case described here - the linked list - it is trivial to determine some run-time characteristics of the list. For example, insertions after a certain element are O(1), while inserting before a specific element is O(N). Some benchmarks in complexity as well as absolute run-time performance may be necessary to make a useful port. In fact, these characteristics are likely the motivating factor for choosing a linked list rather than a memory-contiguous collection. This can be especially critical to specify from the beginning, as such characteristics may get lost in the modelling stage. The more mathematical description of the system likely invokes unrealistic run-time costs due to the usage of sets and the permutations of these to create the model states. This was also noted by the Amazon case study. The assessment of the run-time speed characteristics should likely be done in parallel with the writing of the test code, estimating the complexity characteristics by identifying critical control flow operations such as loops and then verifying these assumptions using tests. Estimating and testing the run-time memory characteristics could be more challenging and is left up to future research.