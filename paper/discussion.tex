
\section{Discussion}\label{discussion}

The usage of formal specifications during the project seemed to increase the certainty that the functionality ported was true to the original; it gave a higher degree of understanding of the design of the target source code. It was beforehand uncertain if basing the model on tests was a valid work process, but the usage of property-based tests provided a usable basis for the model, indicating at least the feasibility of the method. Since the authors experience of working with porting was limited it is difficult to make judgements on the efficiency of this method compared to others. However, the result does not rule out working with the methodology created in this project further.  

The experience of working with TLA+ showed that the language needed some initial investment of time to understand it well enough to apply it in the project. It had a steep learning curve, at least when being used working with programming languages as was the case for the authors. The reason for this is that TLA+ in many ways looks like a regular programming language but in fact works quite differently. For example, the statements in a TLA+ state are commutative; they can be evaluated in any order. This differs a lot from how it works in a language like C where each statement is executed in the order they are written and getting acquainted with this behavior of TLA+ took some time. PlusCal therefore, was a well-received inclusion to the language, making this transition easier. 

For the sample source code chosen for this thesis (see section \ref{frebsd}), the verification step of the process can seem excessive. When porting a more complex system with many modules, each with its own states and transitions that may be valid or not depending on other modules states, it may however be a necessary part of the process and should provide verification to a very high degree that the ported behavior is correct. In the end, the ported code of this project will likely not be used as a standalone linkable library, but instead compiled as part of a bigger project. However, since the source module should be isolated enough to be tested independently, and have formal specifications written for it, building it as a standalone library should pose only a minor issue. If it is not possible to build into a standalone library, it would likely indicate a failure in previous steps of the process.

One of the issues encountered during the project was with the choice of target source code - the linked list. The intended outcome using this as a source, was to reduce the amount of time needed to understand and explain it. This was achieved, but came at a cost. The choice of target source code may have impacted the level of usefulness of the methodology; a complex system may likely benefit greatly if not make it necessary to use a rigorous specification process in preparation for a successful porting. For example, if there are different modules who interact in complex ways, and where some state in module A prohibits some state in module B or vice versa, this is critical information that is expressed best as an invariant. However, if the source is not very complex, the process may prove to be more cumbersome than the value gained from following it. A simple system as the linked list library used in this project has a limited state and does not have any interaction between the different modules. This makes the information gained from a model limited. This is further emphasized if the final module is run through the same tests as the original code, which was the case in this project.

Other possible issues discovered during the project is how to consider implicit functionality and features such as access levels - properties which often differ between programming languages. For example, access levels in C are different from those available in Rust. Properties such as these may need to be considered but are not possible to model and perhaps should be incorporated into the process some other way. How to address these possible situations puts responsibility on the engineer doing the porting. The engineer also needs to consider how the code has originally been used; some use-cases may be strange or abuse unintended functionality. This could be an issue with the methodology used in this project since it puts a large emphasis on matching the original interface, when constraints of the target language may make a similar but different design more suitable. This could, of course, be an issue using any porting methodology. Particularly to this methodology the trade-off is that it provides security that the result conforms to a high degree with the original work. A strict adherence to a model, however, removes some of the freedom from engineers to apply creative solutions and customizations to find a good result. 



\subsection{Validity of Work}
Since the research made in the thesis was mainly of a qualitative design, this section serves the purpose of providing arguments to the trustworthiness of the result. This is accomplished by applying a set of quality criteria \cite{QUALITATIVE}: \textit{credibility}, \textit{transferability}, \textit{dependability}, \textit{confirmability} and \textit{reflexivity}. 

\subsubsection{Credibility}
The premise of this thesis comes from a quite simple question: is it feasible to use formal specifications in a practical way by computer engineers during porting of computer software? Each step of the process is thoroughly presented in the thesis, making it easy for a reader to follow the process without much left to question. The feasibility was evaluated using a metric decided on beforehand. This evaluation was in the form of the verification test-suite run on both the original code and the port. Because of this, it should be clear that the limited conclusions drawn about the feasibility of the methodology are credible.

\subsubsection{Transferability}
Since the methodology was thoroughly described using a step-by-step presentation, it is reasonable to consider it possible for other practitioners in the field to use and improve upon the proposed methodology. It should be general enough for other programming languages and types of functionalities being ported since there is nothing about the languages chosen that should impact the usefulness.

\subsubsection{Dependability}
The dependability of the result should not differ depending on when or by whom an evaluation of the result is being performed. Whether the result will hold stable over time could depend on factors such as an increase in computing power. This could make the process a subject for automation and thereby invalidate any conclusions about the usefulness of the method described. 

\subsubsection{Confirmability}
As a measure of ensuring that this process is repeatable and its results reproducible, the methodology evaluated has been made very explicit. However, as the study was limited in its scope there is a risk that aspects of the methodology were not fully realized which could have prevented the discovery of weaknesses in its execution or structure. This issue could reasonably be considered to have been mitigated to some degree since continuous meetings with the company that proposed the subject were used as performance reviews along during the process. There possible issues were discussed, and solutions and refinement of the methodology was a constant throughout the project.

\subsubsection{Reflexivity}
Reflexivity is the process of critical self-reflection. Since the authors have no formal background in research it is not unlikely that there might have been some bias and preconceptions during the project. For example, knowing the target and source language early on and our preconceptions about them, could have affected the early phases of the research. With another selection process, other languages might have been chosen and a different answer to our question might have been the result.

